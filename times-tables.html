<!DOCTYPE html>
<html lang="en" color-mode="user">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Times Table</title>

    <!-- TODO: I should copy the styles from one of these and just maintain my own styling lib -->
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/holiday.css@0.11.2" /> -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1/new.min.css">
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"> -->
    <!-- <link rel="stylesheet" href="https://unpkg.com/mvp.css">  -->
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css"> -->
    <style>
        :root {
            --color-success: #009000;
            --color-error: #e70d0d;
            --background-body: var(--nc-bg-1)
        }

        .row {
            display: flex;
            justify-content: space-between;
        }

        #heatmapPlot {
            width: 50%;
        }

        #timeseriesPlot {
            width: 50%;
        }

        svg.plot-d6a7b5 {
            --plot-background: var(--background-body);
            background: var(--plot-background);
        }
    </style>
</head>

<body x-data="timesTableApp">
    <header>
        <h1>Times Tables</h1>
        <!-- <button>⚙️</button> -->
    </header>
    <main>
        <div x-show="started">
            <div class="row">
                <div> </div>
                <div class="row">
                    <h1><span x-text="`${a} ${op} ${b} =`"></span></h1>
                    <input type="number" x-model="userAnswer" @keyup.enter="submitAnswer()" />
                </div>
                <button @click="submitAnswer()">Submit</button>
            </div>
        </div>
        <div>
            <button x-text="started ? 'Pause' : 'Start'" @click="started ? pauseGame() : startGame()"></button>
            <details>
                <summary>Options</summary>
                <label for="problemsInSet">Problems in Set:</label>
                <input type="number" x-model="problemsInSet" />
            </details>
        </div>
        <div id="info_panel">
            <div>
                <h2>Stats</h2>
                <div class="row">
                    <p>Correct: <span x-text="stats.correctSubmissions.length"></span></p>
                    <p>Incorrect: <span x-text="stats.incorrectSubmissions.length"></span></p>
                    <p>Accuracy: <span x-text="stats.correctPercent.toFixed(2)"></span>%</p>
                    <p>Average Response Time: <span x-text="(stats.averageResponseTimeMs / 1000).toFixed(2)"></span>s
                    </p>
                </div>
                <select x-model="heatmapView">
                    <option value="responseTime">Select an option</option>
                    <option value="responseTime">Response Time</option>
                    <option value="correctPercent">Percent Correct</option>
                    <option value="timesSeen">Times Seen</option>
                </select>
                <div style="display: flex;">
                    <div id="heatmapPlot"></div>
                    <div id="timeseriesPlot"></div>
                </div>

                <details open>
                    <summary>Events</summary>
                    <table>
                        <thead>
                            <tr>
                                <th>Time</th>
                                <th>Event</th>
                                <th>Problem</th>
                                <th>User Answer</th>
                                <th>Response Time</th>
                            </tr>
                        </thead>
                        <tbody>
                            <template x-for="event in events" :key="event.uuid">
                                <tr>
                                    <td x-text="new Date(event.createdAt).toISOString()"></td>
                                    <td x-text="event.type"></td>
                                    <td x-text="event.a + event.op + event.b"></td>
                                    <td :style='{ color: event.isCorrect ? "var(--color-success)" : "var(--color-error)" }'
                                        x-text="event.userAnswer"></td>
                                    <td x-text="formatMsAsS(event.responseTimeMs)"></td>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </details>
            </div>
    </main>

    <script type="module">
        import Alpine from 'https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/+esm'
        import persist from 'https://cdn.jsdelivr.net/npm/@alpinejs/persist@3.13.3/+esm'
        import * as Plot from "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm";
        window.Alpine = Alpine
        Alpine.plugin(persist)

        function withLRUCache(store, key, fn, maxSize = 100) {
            // Ensure the key is a string, throw an error otherwise
            // make sure the key is a string so iteration is via insertion order
            if (typeof key !== 'string') {
                throw new Error('withLRUCache: Key must be a string to ensure proper cache behavior.');
            }

            // if the key is already in the cache, move it to the "front"
            if (store[key]) {
                // kinda hacky since it relies on the fact that ecmascript's Object.keys
                // returns an iterator based on insertion order for string keys
                const value = store[key];
                delete store[key];
                store[key] = value;
                return value;
            }
            const res = fn(); // cache miss, compute the value

            // if the cache is full, remove the last item
            const keys = Object.keys(store)
            if (keys.length >= maxSize) {
                const lastKey = keys[keys.length - 1];
                delete store[lastKey];
            }
            store[key] = res;
            return res;
        }

        function formatMsAsS(ms) {
            const res = (ms / 1000)
            return Number.isNaN(res) ? undefined : res.toFixed(2) + "s";
        }

        function evaluate(a, b, op) {
            switch (op) {
                case '+':
                    return a + b;
                case '-':
                    return a - b;
                case '*':
                    return a * b;
                case '/':
                    return a / b;
            }
        }

        function timesTableApp() {
            return {
                heatmapView: "responseTime", // correctPercent, responseTime, timesSeen
                userAnswer: '',
                highlightedProblem: "1*1",
                started: false,
                problemsInSet: 10,
                events: Alpine.$persist([]),
                _cache: {},

                get currentProblem() {
                    return withLRUCache(this._cache, `currentProblem-${this.events.length}`, () => {
                        // find the last event that was a GENERATE event and return it
                        for (let i = this.events.length - 1; i >= 0; i--) {
                            const event = this.events[i];
                            if (event.type === "GENERATE") {
                                return event;
                            }
                        }
                        return null;
                    })
                },

                get a() { return this.currentProblem?.a },
                get b() { return this.currentProblem?.b },
                get op() { return this.currentProblem?.op },

                get problemsGenerated() {
                    return withLRUCache(this._cache, `problemsGenerated-${this.events.length}`, () => {
                        return this.events.filter(event => event.type === "GENERATE");;
                    })
                },

                get stats() {
                    return withLRUCache(this._cache, `stats-${this.events.length}`, () => {
                        const correctSubmissions = this.events.filter(event => event.type === "SUBMIT" && event.isCorrect);
                        const incorrectSubmissions = this.events.filter(event => event.type === "SUBMIT" && !event.isCorrect);
                        const totalSubmissions = correctSubmissions.length + incorrectSubmissions.length;
                        const correctPercent = totalSubmissions === 0 ? 0 : correctSubmissions.length / totalSubmissions * 100;
                        const averageResponseTimeMs = correctSubmissions.reduce((sum, event) => sum + event.responseTimeMs, 0) / correctSubmissions.length;

                        // calculate average response time per problem
                        const responseTimesPerProblem = this.events.reduce((m, event) => {
                            if (event.type === "GENERATE") {
                                const name = event.a + event.op + event.b
                                if (m[name]) {
                                    const nxt = { ...m[name] }
                                    nxt.timesSeen += 1
                                    return { ...m, [name]: nxt }
                                }
                                return { ...m, [name]: { name, submissions: [], timesSeen: 1 } }
                            } else if (event.type === "SUBMIT") {
                                const name = event.a + event.op + event.b
                                const nxt = { ...m[name] }
                                nxt.submissions.push(event)
                                return { ...m, [name]: nxt }
                            } else {
                                return m
                            }
                        }, {});

                        const bestResponseTime = Object.keys(responseTimesPerProblem).reduce((best, problem) => {
                            const submissions = responseTimesPerProblem[problem].submissions;
                            let average = submissions.reduce((sum, event) => sum + event.responseTimeMs, 0) / submissions.length;
                            // use 2hrs as a default
                            average = Number.isNaN(average) ? 7_200_000 : average
                            // NOTE: i know its bad but i'm mutating the object here b/c js sucks and its easier
                            responseTimesPerProblem[problem] = { ...responseTimesPerProblem[problem], average };

                            return Math.min(best, average);
                        }, 7_200_000);

                        const res = {
                            correctSubmissions,
                            incorrectSubmissions,
                            totalSubmissions,
                            correctPercent,
                            averageResponseTimeMs,
                            responseTimesPerProblem,
                            bestResponseTime,
                        };
                        return res;
                    })
                },

                configureTimeSeriesPlot(elId) {
                    const getPlot = () => {
                        const data = Object.values(this.stats.responseTimesPerProblem).flatMap(problem =>
                            problem.submissions.map(s => ({
                                name: problem.name, ...s, createdAt: new Date(s.createdAt), responseTimeS: s.responseTimeMs / 1000,
                            })))
                            .filter(it => it.isCorrect && it.name === this.highlightedProblem)
                            .toSorted((a, b) => a.createdAt < b.createdAt ? -1 : 1)

                        return Plot.plot({
                            title: `Response Time Trend For ${this.highlightedProblem}`,
                            // style: {
                            //     background: "var(--background)",
                            // },
                            y: { nice: true },
                            x: { nice: true },
                            marks: [
                                Plot.frame(),
                                Plot.dotY(data, {
                                    x: "createdAt",
                                    y: "responseTimeS",
                                    fill: "name",
                                }),
                                Plot.lineY(data, Plot.windowY({ k: 2 }, { x: "createdAt", y: "responseTimeS", stroke: "median", curve: "auto" })),
                                Plot.tip(data, Plot.pointer({ x: "createdAt", y: "responseTimeS", channels: { problem: "name" } })),
                            ]
                        })
                    }
                    const div = document.getElementById(elId);
                    div?.firstChild?.remove();
                    div.append(getPlot());

                    return () => {
                        div?.firstChild?.remove();
                        div?.append(getPlot())
                    }
                },

                configureHeatmapPlot(elId) {
                    const getPlot = () => {
                        const computeColorOptions = () => {
                            switch (this.heatmapView) {
                                case "correctPercent":
                                    return { scheme: "RdYlGn", reverse: false, pivot: 75 }
                                case "responseTime":
                                    return { scheme: "RdYlGn", reverse: true, pivot: 10 }
                                default:
                                    return { scheme: "rdylbu", reverse: false }
                            }
                        }

                        const computeText = (d) => {
                            switch (this.heatmapView) {
                                case "correctPercent":
                                    return d.correctPercent ? d.correctPercent.toFixed(1) + "%" : undefined
                                case "responseTime":
                                    return d.responseTime ? d.responseTime + "s" : undefined
                                default:
                                    return d[this.heatmapView] ?? undefined
                            }
                        }
                        const problems = Array(10).fill(0)
                            .flatMap((_, i) => Array(10).fill(0).map((_, j) => ({ a: i + 1, b: j + 1 })))
                            .map(it => {
                                const stats = this.calcProblemStats(`${it.a}*${it.b}`)
                                return { ...it, ...stats }
                            })

                        const p = Plot.plot({
                            padding: 0,
                            aspectRatio: 1,
                            x: { axis: "top" },
                            color: computeColorOptions(),
                            marks: [
                                Plot.frame(),
                                Plot.cell(problems, { x: "a", y: "b", fill: this.heatmapView }),
                                Plot.text(problems, { x: "a", y: "b", text: (d) => computeText(d) }),
                                Plot.tip(problems, Plot.pointer({
                                    x: "a", y: "b",
                                    filter: (d) => d.timesSeen > 0,
                                    channels: {
                                        correctPercent: (d) => d.correctPercent + "%",
                                        responseTime: (d) => d.responseTime + "s",
                                        timesSeen: "timesSeen",
                                    },
                                })),
                            ]
                        })

                        p.addEventListener("input", (event) => {
                            if (p?.value?.a === undefined) return;
                            this.highlightedProblem = `${p.value.a}*${p.value.b}`;
                        });

                        return p
                    }

                    const div = document.getElementById(elId);
                    div?.firstChild?.remove();
                    div.append(getPlot());

                    return () => {
                        div?.firstChild?.remove();
                        div?.append(getPlot())
                    }
                },

                init() {
                    window.appEvents = this.events;
                    window.setEventHistory = (history) => {
                        window.confirm("Are you sure you want to overwrite your event history? This will reset your stats and progress.")
                        console.log("setting event history to:", history)
                        this.events = history;
                    }
                    const updateHeatmapFn = this.configureHeatmapPlot("heatmapPlot");
                    const updateTimeseriesFn = this.configureTimeSeriesPlot("timeseriesPlot")

                    this.$watch('heatmapView', () => {
                        updateHeatmapFn();
                        updateTimeseriesFn();
                    });

                    this.$watch('events', () => {
                        updateHeatmapFn();
                        updateTimeseriesFn();
                        window.appEvents = this.events;
                    });

                    this.$watch('highlightedProblem', () => {
                        updateTimeseriesFn();
                    });
                },

                calcProblemStats(problem, op, b) {
                    if (op !== undefined && b != undefined) {
                        return this.calcProblemStats(`${problem}${op}${b}`);
                    }
                    const { bestResponseTime, responseTimesPerProblem } = this.stats
                    const { submissions, average, timesSeen } = responseTimesPerProblem[problem] ?? { submissions: [], average: 0, timesSeen: 0 };
                    const correct = submissions.filter(event => event.isCorrect).length;
                    const incorrect = submissions.filter(event => !event.isCorrect).length;
                    const correctPercent = correct / submissions.length * 100;
                    return {
                        normalizedResponseTime: Number.isNaN(average) ? 0 : bestResponseTime / average,
                        // convert to seconds and make it pretty
                        responseTime: average === 0 ? undefined : Math.round((average / 1000) * 1e2) / 1e2,
                        correct,
                        incorrect,
                        timesSeen,
                        correctPercent,
                    };
                },

                startGame() {
                    alert("starting game in... 3!")
                    alert("starting game in... 2!")
                    alert("starting game in... 1!")
                    alert("go!!!!!!")
                    this.started = true;
                    this.generateProblem();
                },
                pauseGame() {
                    this.started = false;
                    // remove any wrong answers
                    while (this.events.length > 0 && this.events[this.events.length - 1].type === "SUBMIT") {
                        this.events.pop();
                    }
                    // remove the last generated question
                    this.events.pop();
                },
                generateProblem() {
                    this.userAnswer = '';
                    const event = {
                        uuid: crypto.randomUUID(),
                        type: "GENERATE",
                        a: Math.floor(Math.random() * 10) + 1,
                        b: Math.floor(Math.random() * 10) + 1,
                        op: "*",
                        createdAt: Date.now(),
                    };
                    this.events.push(event);
                },
                submitAnswer() {
                    const currentProblem = this.currentProblem;
                    const createdAt = Date.now()
                    const correctAnswer = evaluate(this.a, this.b, this.op);
                    const userAnswer = parseInt(this.userAnswer)
                    const isCorrect = userAnswer === correctAnswer;

                    const event = {
                        uuid: crypto.randomUUID(),
                        type: "SUBMIT",
                        isCorrect,
                        correctAnswer,
                        userAnswer,
                        a: currentProblem.a,
                        b: currentProblem.b,
                        op: currentProblem.op,
                        createdAt,
                        responseTimeMs: createdAt - currentProblem.createdAt,
                    };

                    this.events.push(event);

                    if (isCorrect) {
                        if (this.started && this.problemsGenerated.length % this.problemsInSet === 0) {
                            this.started = false;
                            alert("You've completed the set! Congrats!")
                            return;
                        }
                        this.generateProblem();
                    } else {
                        alert('Wrong answer, try again!');
                    }
                },
                eventString(event) {
                    return `${new Date(event.createdAt).toISOString()}: ${event.type} ${event.a} ${event.op} ${event.b} ${(event?.responseTimeMs && event.responseTimeMs / 1000 + "s") ?? ""}`;
                }
            };
        }

        // TODO: figure out how to make these available without polluting the global namespace
        window.withLRUCache = withLRUCache;
        window.formatMsAsS = formatMsAsS;
        window.evaluate = evaluate;
        Alpine.data('timesTableApp', timesTableApp)

        // NOTE: must be called only once and at the end
        Alpine.start();
    </script>
</body>

</html>